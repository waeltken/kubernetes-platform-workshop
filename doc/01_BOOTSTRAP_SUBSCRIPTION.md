## Bootstrap your Azure Subscription for use with Terraform

Terraform uses a backend to store the state of your infrastructure. This state
is used by Terraform to map real world resources to your configuration, keep
track of metadata, and to improve performance for large infrastructures. In
order to make use of the Azure backend, we need to create a storage account and
a container to store the state file.

This state file will also be used for locking, which prevents concurrent runs of
Terraform against the same state file.

We can use terraform itself to create the storage account and container. To do
this, we will use the [AzureRM
Provider](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs).

Create a new directory for your Terraform configuration and create a file called
`main.tf` in it. Add the following content to the file:

<!-- CODE:BASH:START -->
<!-- echo '```hcl' -->
<!-- cat code/bootstrap/main.tf -->
<!-- echo '```' -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```hcl
provider "azurerm" {
  features {}
}

provider "random" {}

resource "random_id" "random_id" {
  byte_length = 4
}

resource "azurerm_resource_group" "terraform_state" {
  name     = "terraform-state"
  location = "westeurope"
}

resource "azurerm_storage_account" "terraform_state" {
  name                     = "terraformstate${random_id.random_id.hex}"
  resource_group_name      = azurerm_resource_group.terraform_state.name
  location                 = azurerm_resource_group.terraform_state.location
  account_tier             = "Standard"
  account_replication_type = "LRS"
}

resource "azurerm_storage_container" "terraform_state" {
  name                  = "terraform-state"
  storage_account_name  = azurerm_storage_account.terraform_state.name
  container_access_type = "private"
}
```

<!-- OUTPUT:END -->

We can then run `terraform init` to initialize terraform and download the
required providers.

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd code/bootstrap && terraform init -no-color -->
<!-- echo '```' -->
<!-- CODE:END -->

<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```

Initializing the backend...

Initializing provider plugins...
- Finding latest version of hashicorp/random...
- Finding latest version of hashicorp/azurerm...
- Installing hashicorp/random v3.5.1...
- Installed hashicorp/random v3.5.1 (signed by HashiCorp)
- Installing hashicorp/azurerm v3.75.0...
- Installed hashicorp/azurerm v3.75.0 (signed by HashiCorp)

Terraform has created a lock file .terraform.lock.hcl to record the provider
selections it made above. Include this file in your version control repository
so that Terraform can guarantee to make the same selections by default when
you run "terraform init" in the future.

Terraform has been successfully initialized!

You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.

If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.
```

<!-- OUTPUT:END -->

Log in to Azure using the Azure CLI and make sure you select the correct
subscription:

```zsh
az login
az account show -o yaml
```

If you need to change the subscription, you can do so using the following
command:

```zsh
az account set --subscription <subscription-id>
```

Now let's run `terraform apply` to create the storage account and container:

```zsh
terraform apply
```

Make sure to confirm the prompt by typing `yes`. After a few seconds, you should
see the following output:

<!-- CODE:BASH:START -->
<!-- echo '```' -->
<!-- cd code/bootstrap && terraform apply -auto-approve -no-color -->
<!-- echo '```' -->
<!-- CODE:END -->
<!-- OUTPUT:START -->
<!-- ⚠️ This content is auto-generated by `markdown-code-runner`. -->
```

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  + create

Terraform will perform the following actions:

  # azurerm_resource_group.terraform_state will be created
  + resource "azurerm_resource_group" "terraform_state" {
      + id       = (known after apply)
      + location = "westeurope"
      + name     = "terraform-state"
    }

  # azurerm_storage_account.terraform_state will be created
  + resource "azurerm_storage_account" "terraform_state" {
      + access_tier                       = (known after apply)
      + account_kind                      = "StorageV2"
      + account_replication_type          = "LRS"
      + account_tier                      = "Standard"
      + allow_nested_items_to_be_public   = true
      + cross_tenant_replication_enabled  = true
      + default_to_oauth_authentication   = false
      + enable_https_traffic_only         = true
      + id                                = (known after apply)
      + infrastructure_encryption_enabled = false
      + is_hns_enabled                    = false
      + large_file_share_enabled          = (known after apply)
      + location                          = "westeurope"
      + min_tls_version                   = "TLS1_2"
      + name                              = (known after apply)
      + nfsv3_enabled                     = false
      + primary_access_key                = (sensitive value)
      + primary_blob_connection_string    = (sensitive value)
      + primary_blob_endpoint             = (known after apply)
      + primary_blob_host                 = (known after apply)
      + primary_connection_string         = (sensitive value)
      + primary_dfs_endpoint              = (known after apply)
      + primary_dfs_host                  = (known after apply)
      + primary_file_endpoint             = (known after apply)
      + primary_file_host                 = (known after apply)
      + primary_location                  = (known after apply)
      + primary_queue_endpoint            = (known after apply)
      + primary_queue_host                = (known after apply)
      + primary_table_endpoint            = (known after apply)
      + primary_table_host                = (known after apply)
      + primary_web_endpoint              = (known after apply)
      + primary_web_host                  = (known after apply)
      + public_network_access_enabled     = true
      + queue_encryption_key_type         = "Service"
      + resource_group_name               = "terraform-state"
      + secondary_access_key              = (sensitive value)
      + secondary_blob_connection_string  = (sensitive value)
      + secondary_blob_endpoint           = (known after apply)
      + secondary_blob_host               = (known after apply)
      + secondary_connection_string       = (sensitive value)
      + secondary_dfs_endpoint            = (known after apply)
      + secondary_dfs_host                = (known after apply)
      + secondary_file_endpoint           = (known after apply)
      + secondary_file_host               = (known after apply)
      + secondary_location                = (known after apply)
      + secondary_queue_endpoint          = (known after apply)
      + secondary_queue_host              = (known after apply)
      + secondary_table_endpoint          = (known after apply)
      + secondary_table_host              = (known after apply)
      + secondary_web_endpoint            = (known after apply)
      + secondary_web_host                = (known after apply)
      + sftp_enabled                      = false
      + shared_access_key_enabled         = true
      + table_encryption_key_type         = "Service"
    }

  # azurerm_storage_container.terraform_state will be created
  + resource "azurerm_storage_container" "terraform_state" {
      + container_access_type   = "private"
      + has_immutability_policy = (known after apply)
      + has_legal_hold          = (known after apply)
      + id                      = (known after apply)
      + metadata                = (known after apply)
      + name                    = "terraform-state"
      + resource_manager_id     = (known after apply)
      + storage_account_name    = (known after apply)
    }

  # random_id.random_id will be created
  + resource "random_id" "random_id" {
      + b64_std     = (known after apply)
      + b64_url     = (known after apply)
      + byte_length = 4
      + dec         = (known after apply)
      + hex         = (known after apply)
      + id          = (known after apply)
    }

Plan: 4 to add, 0 to change, 0 to destroy.
random_id.random_id: Creating...
random_id.random_id: Creation complete after 0s [id=PTciEg]
azurerm_resource_group.terraform_state: Creating...
```

<!-- OUTPUT:END -->

We have successfully created our terraform backend. We can now use it to store
the state of our infrastructure for the rest of the workshop.

Note that we will not use the folder that we created in this section anymore.
The bootstrapping has created it's own state file locally on your machines
filesystem. This is one of the very few exceptions where you can not use a
remote backend. You could even consider committing the state file to version
control, although this is generally not recommended.

<!-- CODE:BASH:START -->
<!-- cd code/bootstrap && terraform apply -destroy -auto-approve -no-color -->
<!-- rm -rf .terraform -->
<!-- rm .terraform.lock.hcl -->
<!-- rm terraform.tfstate -->
<!-- CODE:END -->
